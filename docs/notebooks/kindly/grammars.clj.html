<html><body><div><pre><code>&quot;(ns kindly.grammars\n  (:require [clojure.java.io :as io]\n            [malli.core :as ma])\n  (:import (javax.imageio ImageIO)))&quot;</code></pre><div><pre><code>nil</code></pre></div></div><div># Kindly grammars
</div><div>Notebooks and rich REPLs visualize data and objects.
Kindly seeks to establish a standard way for users to request visualizations.
</div><div>Nesting is an important consideration.
For example a table might contain an image in a cell.
</div><div>## HTML (hiccup)
</div><div>HTML is the most flexible visualization,
as you can represent pretty much anything that can display in a browser.
</div><div><pre><code>&quot;(def hiccup-table\n  ^:kindly/hiccup\n  [:table\n   [:tr [:td 1] [:td 2]]\n   [:tr [:td 3] [:td 4]]])&quot;</code></pre><div>VAR#&apos;kindly.grammars/hiccup-table</div></div><div>The downside of HTML is that users need to expend considerable effort reshaping their data into views.
</div><div>Hiccup has a Malli schema that can be used to validate and parse:
</div><div><pre><code>&quot;(def Hiccup\n  [:schema {:registry {\&quot;hiccup\&quot; [:orn\n                                 [:node [:catn\n                                         [:name keyword?]\n                                         [:props [:? [:map-of keyword? any?]]]\n                                         [:children [:* [:schema [:ref \&quot;hiccup\&quot;]]]]]]\n                                 [:primitive [:orn\n                                              [:nil nil?]\n                                              [:boolean boolean?]\n                                              [:number number?]\n                                              [:text string?]]]]}}\n   \&quot;hiccup\&quot;])&quot;</code></pre><div>VAR#&apos;kindly.grammars/Hiccup</div></div><div>Hiccup does not check for the creation of valid HTML; tags and attributes are not checked.
</div><div><pre><code>&quot;(def parse-hiccup (ma/parser Hiccup))&quot;</code></pre><div>VAR#&apos;kindly.grammars/parse-hiccup</div></div><div><pre><code>&quot;(parse-hiccup hiccup-table)&quot;</code></pre><div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:table</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:tr</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:td</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:primitive</code></pre></div><div>[<div><pre><code>:number</code></pre></div><div><pre><code>1</code></pre></div>]</div>]</div>]</div>]</div>}</div>]</div><div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:td</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:primitive</code></pre></div><div>[<div><pre><code>:number</code></pre></div><div><pre><code>2</code></pre></div>]</div>]</div>]</div>]</div>}</div>]</div>]</div>]</div>}</div>]</div><div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:tr</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:td</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:primitive</code></pre></div><div>[<div><pre><code>:number</code></pre></div><div><pre><code>3</code></pre></div>]</div>]</div>]</div>]</div>}</div>]</div><div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:td</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:primitive</code></pre></div><div>[<div><pre><code>:number</code></pre></div><div><pre><code>4</code></pre></div>]</div>]</div>]</div>]</div>}</div>]</div>]</div>]</div>}</div>]</div>]</div>]</div>}</div>]</div></div><div>## Tables
</div><div>Tables are interesting because one can imagine users with data in many different shapes;
vectors of vectors, vectors of maps, Tablecloth datasets, or maybe something else.
</div><div><pre><code>&quot;^:kind/table\n{:headers     []\n :row-vectors []}&quot;</code></pre><div>TABLE{:headers [], :row-vectors []}</div></div><div><pre><code>&quot;^:kind/table\n{:headers     []\n :row-maps []}&quot;</code></pre><div>TABLE{:row-maps [], :headers []}</div></div><div><pre><code>&quot;^:kind/table\n[[1 2]\n [3 4]]&quot;</code></pre><div>TABLE[[1 2] [3 4]]</div></div><div>It would be convenient to allow users several options for table inputs,
and some transformations to standardize them for downstream tools.
Perhaps this can be achieved with a shorthand helper?
</div><div><pre><code>&quot;&apos;(tabulate values)&quot;</code></pre><div><pre><code>tabulate</code></pre></div><div><pre><code>values</code></pre></div></div><div><pre><code>&quot;&apos;(tabulate headers values)&quot;</code></pre><div><pre><code>tabulate</code></pre></div><div><pre><code>headers</code></pre></div><div><pre><code>values</code></pre></div></div><div>Possibly a multimethod (with a row multimethod as well).
</div><div>Tools should be encouraged to accept a standardized data shape defined by a schema:
</div><div><pre><code>&quot;(def Table\n  [:schema {:registry {\&quot;table\&quot; [&apos;...]}}\n   \&quot;table\&quot;])&quot;</code></pre><div>VAR#&apos;kindly.grammars/Table</div></div><div>## Plots
</div><div>Plots have the richest grammar.
Two popular grammars for plotting are Vega and ggplot2.
</div><div><pre><code>&quot;^:kind/vega\n{}&quot;</code></pre><div><div>Unimplemented: <code>:kind/vega</code></div><pre><code>{}</code></pre></div></div><div>Vega has json-schemas available which are comprehensive.
There is not yet a way to create Malli schemas from Vega json-schema.
We could use a json-schema library instead,
or improve Malli schema conversion.
</div><div>## Images
</div><div>No grammar is necessary for images.
</div><div>Images can be specified using Markdown syntax:

    ![a heart](claykind.png)

![a heart](../../../claykind.png)

Managing the path to images can be challenging for users.
</div><div>It is nice to be able to use &quot;send form to Portal&quot; or similar, can this be done with Markdown?
</div><div><pre><code>&quot;(ImageIO/read (io/file \&quot;claykind.png\&quot;))&quot;</code></pre><div><div>Unimplemented: <code>:kind/buffered-image</code></div><pre><code>#object[java.awt.image.BufferedImage 0x74d620f7 &quot;BufferedImage@74d620f7: type = 6 ColorModel: #pixelBits = 32 numComponents = 4 color space = java.awt.color.ICC_ColorSpace@13651c4 transparency = 3 has alpha = true isAlphaPre = false ByteInterleavedRaster: width = 256 height = 256 #numDataElements 4 dataOff[0] = 3&quot;]</code></pre></div></div><div>Users may benefit from a shorthand helper function `(image &quot;claykind.png&quot;)`.
</div><div>sometimes the filename will be calculated programmatically,
which would be teadious to achieve with markdown.
</div><div>## Reagent components
</div><div>A grammar is not possible for functions, or Reagent components.
</div><div>## Tablecloth datasets
</div><div>Tablecloth datasets are identifiable by their type.
</div><div>## Markdown
</div><div>Markdown comes in different flavours,
for example GitHub Markdown and Quarto (qmd).
Downstream tools may benefit from a hint as to which flavor should be used.
Users probably don&apos;t want to have to think too much about this though.
</div><div>Of particular interest is the display of mathematical equations,
which often require plugin support.
</div><div>$ f(x) = x^2 $
</div><div>Should render as an equation.
</div><div>Somewhat surprisingly, we cannot rely entirely on comments to represent Markdown.
We might need to construct Markdown programmatically.
</div><div><pre><code>&quot;^:kindly/markdown\n(str \&quot;## This... is... \&quot; :Markdown)&quot;</code></pre><div><pre><code>&quot;## This... is... :Markdown&quot;</code></pre></div></div><div>## Data
</div><div>No grammar is necessary for primitives and collections.
</div><div><pre><code>&quot;{:this #{\&quot;is\&quot;}\n &apos;data [1 2 3 nil]}&quot;</code></pre><div>{<div>[<div><pre><code>:this</code></pre></div><div>#{<div><pre><code>&quot;is&quot;</code></pre></div>}</div>]</div><div>[<div><pre><code>data</code></pre></div><div>[<div><pre><code>1</code></pre></div><div><pre><code>2</code></pre></div><div><pre><code>3</code></pre></div><div><pre><code>nil</code></pre></div>]</div>]</div>}</div></div><div>One challenge is when the data is very large.
Ideally some preview would be available.
</div></body></html>