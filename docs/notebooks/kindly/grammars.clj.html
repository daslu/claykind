<!DOCTYPE html>
<html><head><script src="https://unpkg.com/react@18/umd/react.production.min.js" type="text/javascript"></script><script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" type="text/javascript"></script><script src="https://scicloj.github.io/scittle/js/scittle.js" type="text/javascript"></script><script src="https://scicloj.github.io/scittle/js/scittle.reagent.js" type="text/javascript"></script><script src="https://cdn.jsdelivr.net/npm/vega@5" type="text/javascript"></script><script src="https://cdn.jsdelivr.net/npm/vega-lite@5" type="text/javascript"></script><script src="https://cdn.jsdelivr.net/npm/vega-embed@6" type="text/javascript"></script><script src="portal-main.js" type="text/javascript"></script><script src="http://localhost:52509/main.js?" type="text/javascript"></script></head><body><div><pre><code>nil</code></pre></div><div># Kindly grammars
</div><div>Notebooks and rich REPLs visualize data and objects.
Kindly seeks to establish a standard way for users to request visualizations.
</div><div>Nesting is an important consideration.
For example a table might contain an image in a cell.
</div><div>## HTML (hiccup)
</div><div>HTML is the most flexible visualization,
as you can represent pretty much anything that can display in a browser.
</div><div>VAR#'kindly.grammars/hiccup-table</div><div>The downside of HTML is that users need to expend considerable effort reshaping their data into views.
</div><div>Hiccup has a Malli schema that can be used to validate and parse:
</div><div>VAR#'kindly.grammars/Hiccup</div><div>Hiccup does not check for the creation of valid HTML; tags and attributes are not checked.
</div><div>VAR#'kindly.grammars/parse-hiccup</div><div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:table</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:tr</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:td</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:primitive</code></pre></div><div>[<div><pre><code>:number</code></pre></div><div><pre><code>1</code></pre></div>]</div>]</div>]</div>]</div>}</div>]</div><div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:td</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:primitive</code></pre></div><div>[<div><pre><code>:number</code></pre></div><div><pre><code>2</code></pre></div>]</div>]</div>]</div>]</div>}</div>]</div>]</div>]</div>}</div>]</div><div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:tr</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:td</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:primitive</code></pre></div><div>[<div><pre><code>:number</code></pre></div><div><pre><code>3</code></pre></div>]</div>]</div>]</div>]</div>}</div>]</div><div>[<div><pre><code>:node</code></pre></div><div>{<div>[<div><pre><code>:name</code></pre></div><div><pre><code>:td</code></pre></div>]</div><div>[<div><pre><code>:props</code></pre></div><div><pre><code>nil</code></pre></div>]</div><div>[<div><pre><code>:children</code></pre></div><div>[<div>[<div><pre><code>:primitive</code></pre></div><div>[<div><pre><code>:number</code></pre></div><div><pre><code>4</code></pre></div>]</div>]</div>]</div>]</div>}</div>]</div>]</div>]</div>}</div>]</div>]</div>]</div>}</div>]</div><div>## Tables
</div><div>Tables are interesting because one can imagine users with data in many different shapes;
vectors of vectors, vectors of maps, Tablecloth datasets, or maybe something else.
</div><div>TABLE{:headers [], :row-vectors []}</div><div>TABLE{:row-maps [], :headers []}</div><div>TABLE[[1 2] [3 4]]</div><div>It would be convenient to allow users several options for table inputs,
and some transformations to standardize them for downstream tools.
Perhaps this can be achieved with a shorthand helper?
</div><div><div><pre><code>tabulate</code></pre></div><div><pre><code>values</code></pre></div></div><div><div><pre><code>tabulate</code></pre></div><div><pre><code>headers</code></pre></div><div><pre><code>values</code></pre></div></div><div>Possibly a multimethod (with a row multimethod as well).
</div><div>Tools should be encouraged to accept a standardized data shape defined by a schema:
</div><div>VAR#'kindly.grammars/Table</div><div>## Plots
</div><div>Plots have the richest grammar.
Two popular grammars for plotting are Vega and ggplot2.
</div><div>VAR#'kindly.grammars/vega-lite-point-plot</div><div>VAR#'kindly.grammars/random-data</div><div>VAR#'kindly.grammars/random-vega-lite-plot</div><div id="widget29"></div><script type="application/x-scittle">((fn [id] (js/vegaEmbed (str "#" id) (clj->js (quote {:encoding {:y {:field "y", :type "quantitative"}, :fill {:field "z", :type "nominal"}, :size {:field "w", :type "quantitative"}, :x {:field "x", :type "quantitative"}}, :mark "point", :data {:values ({:y -0.4275751678440296, :w 2, :z 3, :x 0} {:y 0.03798066856106774, :w 4, :z 8, :x 1} {:y 0.03116107075061325, :w 0, :z 7, :x 2} {:y 0.29780079004265714, :w 8, :z 1, :x 3} {:y 0.6401328373088503, :w 7, :z 5, :x 4} {:y 0.532597441774286, :w 1, :z 5, :x 5} {:y 0.13005293287901254, :w 1, :z 8, :x 6} {:y 0.19810803073784322, :w 2, :z 0, :x 7} {:y 0.6779143736640543, :w 6, :z 4, :x 8})}})))) "widget29")</script><div>Vega has json-schemas available which are comprehensive.
There is not yet a way to create Malli schemas from Vega json-schema.
We could use a json-schema library instead,
or improve Malli schema conversion.
</div><div>## Images
</div><div>No grammar is necessary for images.
</div><div>Images can be specified using Markdown syntax:

    ![a heart](claykind.png)

![a heart](../../../claykind.png)

Managing the path to images can be challenging for users.
</div><div>It is nice to be able to use "send form to Portal" or similar, can this be done with Markdown?
</div><img src="BufferedImage@43a08b91: type = 6 ColorModel: #pixelBits = 32 numComponents = 4 color space = java.awt.color.ICC_ColorSpace@46f20caa transparency = 3 has alpha = true isAlphaPre = false ByteInterleavedRaster: width = 256 height = 256 #numDataElements 4 dataOff[0] = 3"><div>Users may benefit from a shorthand helper function `(image "claykind.png")`.
</div><div>sometimes the filename will be calculated programmatically,
which would be teadious to achieve with markdown.
</div><div>## Reagent components
</div><div>A grammar is not possible for functions, or Reagent components.
</div><div>## Tablecloth datasets
</div><div>Tablecloth datasets are identifiable by their type.
</div><div>## Markdown
</div><div>Markdown comes in different flavours,
for example GitHub Markdown and Quarto (qmd).
Downstream tools may benefit from a hint as to which flavor should be used.
Users probably don't want to have to think too much about this though.
</div><div>Of particular interest is the display of mathematical equations,
which often require plugin support.
</div><div>$ f(x) = x^2 $
</div><div>Should render as an equation.
</div><div>Somewhat surprisingly, we cannot rely entirely on comments to represent Markdown.
We might need to construct Markdown programmatically.
</div><div><pre><code>"## This... is... :Markdown"</code></pre></div><div>## Data
</div><div>No grammar is necessary for primitives and collections.
</div><div>{<div>[<div><pre><code>:this</code></pre></div><div>#{<div><pre><code>"is"</code></pre></div>}</div>]</div><div>[<div><pre><code>data</code></pre></div><div>[<div><pre><code>1</code></pre></div><div><pre><code>2</code></pre></div><div><pre><code>3</code></pre></div><div><pre><code>nil</code></pre></div>]</div>]</div>}</div><div>One challenge is when the data is very large.
Ideally some preview would be available.
</div></body></html>